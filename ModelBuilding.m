(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["Susyno`ModelBuilding`",{"Susyno`LieGroups`","Susyno`SusyRGEs`","Susyno`IO`"}]

{SearchForInvariants,GenerateModelParameters,GenerateModel};

(* properties of a model - see TagSet and Upset (e.g.:area[square]^=1)*)
{group,reps,nFlavs,discreteSym,conjugateReps,nReps,parameters,lagrangian,betaFunctions,parameterRenamingRules};

(* properties of a model due to SSB *)
{fundamentalModel,definingVevs,gaugeRotation,matterRotation,boundaryConditions};

(* These are the default Susyno names for the parameters of the model *)
{originalParameters,parameterTransformationRule};

(* parametersSymmetries contains the symmetries of the model parameters; the optional variable fieldNames contains a model's field names *)
{parametersSymmetries,fieldNames};

(* Simplify the parameter names and eliminate some of them *)
{ExcludeUnrealizableParameters,CutUnwantedFlavourIndices,CutUnwantedInvariantIndices,UseFieldNames};

{PrintModelInformation};

{IsModelAnomalyFree};

{CalculateLagrangian,f1,f2,f3,PrintHeaderText,PrintHeaderText2,PrintHeaderText3};

{g,M,f,y,\[Mu],l,h,b,s,m2};

{CalculateEverything};

{PrintAllModelInformation};

Begin["Private`"];

(* This method should be form internal use only *)
RenameParametersWithRules[model_, ruleList_]:=Module[{aux},

lagrangian[model]^=lagrangian[model]//.ruleList;
betaFunctions[model]^=betaFunctions[model]//.ruleList;
parameters[model]^=parameters[model]//.ruleList;
parameterTransformationRule[model]^=If[ValueQ[parameterTransformationRule[model]],Append[parameterTransformationRule[model],ruleList],{ruleList}];
]

(* If this method is called, all variables associated with a model are computed and made available *)
Options[GenerateModel]={CalculateEverything->False,Verbose->True};
GenerateModel[model_,OptionsPattern[]]:=Module[{},
If[CheckModel[model],
(* Reset transformation rules *)
parameterTransformationRule[model]^={};
If[!ValueQ[parameterRenamingRules[model]],parameterRenamingRules[model]^={}]; (* These are user defined rules *)

GenerateModelParameters[model];
GenerateModelBetaFunctions[model];
parameters[model]^=parameters[model]//.parameterRenamingRules[model];
betaFunctions[model]^=betaFunctions[model]//.parameterRenamingRules[model];

If[OptionValue[CalculateEverything],
CalculateLagrangian[model,Verbose->False];
lagrangian[model]^=lagrangian[model]//.parameterRenamingRules[model];
];

(* Things to include: model name; model group; model representations; nFlavs; discreteSyms; model parameters; model beta functions; *)
If[OptionValue[Verbose],PrintAllModelInformation[model]];
];
]
(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)

(* Any input with group, reps, fieldNames, nFlavs and discreteSym defined will trigger the execution of PrintAllModelInformation *)

(*
$Pre=If[ValueQ[group[#]]&&ValueQ[reps[#]]&&ValueQ[fieldNames[#]]&&ValueQ[nFlavs[#]]&&ValueQ[discreteSym[#]],PrintAllModelInformation[#],#]&;
*)


SetAttributes[myPre, HoldAll];
myPre[input_]:=Module[{aux,groupNames},
aux=ToString[Unevaluated[input]];
groupNames=Join[StringCases[aux,RegularExpression["(?i)SU[0-9]+"],IgnoreCase->True],StringCases[aux,RegularExpression["(?i)SO[0-9]+"],IgnoreCase->True],StringCases[aux,RegularExpression["(?i)SP[0-9]+"],IgnoreCase->True],Names[RegularExpression["(?i)SU[0-9]+"],IgnoreCase->True],Names[RegularExpression["(?i)SO[0-9]+"],IgnoreCase->True],Names[RegularExpression["(?i)SP[0-9]+"],IgnoreCase->True]];

(If[Head[ToExpression[#]]==Symbol,Evaluate[ToExpression[#]]=CartanMatrix[StringTake[#,2],ToExpression[StringDrop[#,2]]]])&/@groupNames;

Return[Evaluate[input]];];

$Pre=myPre;



myPost[input_]:=Module[{},
If[ValueQ[group[input]]&&ValueQ[reps[input]]&&ValueQ[fieldNames[input]]&&ValueQ[nFlavs[input]]&&ValueQ[discreteSym[input]],PrintAllModelInformation[input],Return[input]];
];
$Post=myPost;


PrintAllModelInformation[model_]:=Module[{},

(* First make user that user defined substitutions, defined after the last GenerateModel was executed, are indeed implemented *)
If[ValueQ[parameterRenamingRules[model]],
parameters[model]^=parameters[model]//.parameterRenamingRules[model];
betaFunctions[model]^=betaFunctions[model]//.parameterRenamingRules[model];
If[ValueQ[lagrangian[model]],
lagrangian[model]^=lagrangian[model]//.parameterRenamingRules[model];
]
];


PrintModelName[model];
PrintModelGaugeGoup[model];
PrintModelRepresentations[model];
PrintModelParameters[model];
PrintParametersSymmetries[model];
PrintLagrangian[model];
PrintModelBetaFunctions[model];
];

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)

IsModelAnomalyFree[model_]:=Module[{anomalyValues},
anomalyValues=Total[nFlavs[model] (TriangularAnomalyValue[group[model],#]&/@reps[model])];Which[anomalyValues===0anomalyValues,Return[True],anomalyValues=!=0anomalyValues,Return[False],True,Print["The model is anomaly if and only if ",anomalyValues, " are all zero."]];
]

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)

PrintModelInformation[model_,twoLoops_:True]:=Module[{auxP,aux\[Beta]1,aux\[Beta]2},
auxP=Flatten[parameters[model]];
aux\[Beta]1=Expand[Flatten[betaFunctions[model][[All,1]]]];

If[twoLoops,aux\[Beta]2=Expand[Flatten[betaFunctions[model][[All,2]]]]];

Print[Style["XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",{Bold,GrayLevel[0.5]}]];

Do[
Print[Style[">>> ",{Bold}],Style["Parameter name:",{Bold,Darker[Red]}]];
Print[auxP[[i]]];
Print[""];
Print[Style[">>> ",{Bold}],Style["1-Loop \[Beta] function:",{Bold,Darker[Red]}]];
Print[aux\[Beta]1[[i]]];
Print[""];
If[twoLoops,
Print[Style[">>> ",{Bold}],Style["2-Loop \[Beta] function:",{Bold,Darker[Red]}]];
Print[aux\[Beta]2[[i]]];
Print[""];
];
Print[Style["XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",{Bold,GrayLevel[0.5]}]];
Print[""];

,{i,Length[auxP]}];

]

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)
(* XXXXXXXXXXXXXXXXXXXXXXXXX Generating the model's parameters XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)
(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)

(* Returns the position and multiplicity in 'reps' of the representations that form trilinear invariants with reps[[i]] and reps[[j]]. Only representations with a position bigger than j will be returned. The output is {{rep1 position, # invariants with rep1},...} *)
SearchForInvariants[model_,i_,j_]:=Module[{aux,result,discreteCharge},
aux=Simplify[ReduceRepProduct[group[model],{reps[model][[i]],reps[model][[j]]}]];
discreteCharge=discreteSym[model][[i]] discreteSym[model][[j]];
aux=Table[{{aux[[k,1]],discreteCharge},aux[[k,2]]},{k,Length[aux]}];
aux=DeleteCases[aux,x_/;!MemberQ[conjugateReps[model][[j;;-1]],x[[1]],{1}]];
result={j-1+(Position[conjugateReps[model][[j;;-1]],#[[1]]])[[All,1]],#[[2]]}&/@aux;

result=Flatten[Table[{result[[c1,1,c2]],result[[c1,2]]},{c1,Length[result]},{c2,Length[result[[c1,1]]]}],1];
Return[result];
]

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)

GenerateModelParameters[model_]:=Module[{aux,conjugateRs,nonU1sPositions,u1sPositions,nU1s,gMatrix,mMatrix,pY,p\[Mu],pL,pH,pB,pS,pM2,modelParametersSusyno},

(* Calculate and set the model's conjugate representations *)
conjugateRs=ConjugateIrrep[group[model],#]&/@reps[model];
conjugateRs=Thread[{conjugateRs,1/discreteSym[model]}];

conjugateReps[model]^=conjugateRs;

(* Set the number of representations *)
nReps[model]^=Length[reps[model]];


aux=Table[SearchForInvariants[model,i,j],{i,nReps[model]},{j,i,nReps[model]}];
aux=Table[{i,i+j-1,aux[[i,j,k,1]],aux[[i,j,k,2]]},{i,Length[aux]},{j,Length[aux[[i]]]},{k,Length[aux[[i,j]]]}];
aux=Flatten[aux,2];
(* aux now contains a list with (index1,index2,index3,multiplicity) of each trilinear parameter allowed by the model *)
(* Get all the Yukawa parameters *)
pY=Flatten[Table[y[aux[[i,1;;3]],j,{f[1],f[2],f[3]}],{i,Length[aux]},{j,aux[[i,4]]}],1];
pH=pY/.y->h;
(* [end]Get all the Yukawa parameters *)

(* Get all the bilinear parameters *)
aux=Table[If[{reps[model][[i]],discreteSym[model][[i]]}==conjugateRs[[j]],{i,j},Null],{i,nReps[model]},{j,i,nReps[model]}];
aux=Flatten[aux,1];
aux=DeleteCases[aux,Null,{1}];
p\[Mu]=Table[\[Mu][aux[[i]],{f[1],f[2]}],{i,Length[aux]}];
pB=p\[Mu]/.\[Mu]->b;
(* [end]Get all the bilinear parameters *)

(* Get all the linear parameters *)
aux={conjugateRs[[1,1]]0,conjugateRs[[1,2]]0+1};
aux=Position[conjugateRs,aux,{1}];

pL=Table[l[aux[[i]],{f[1]}],{i,Length[aux]}];
pS=pL/.l->s;
(* [end]Get all the linear parameters *)

(* Get all mass parameters *)
(* pM2=Array[m2[{#,#},{f[1],f[2]}]&,nReps[model]]; *)

aux=Table[If[{reps[model][[i]],discreteSym[model][[i]]}=={reps[model][[j]],discreteSym[model][[j]]},{i,j},Null],{i,nReps[model]},{j,i,nReps[model]}];
aux=Flatten[aux,1];
aux=DeleteCases[aux,Null,{1}];
pM2=Table[m2[aux[[i]],{f[1],f[2]}],{i,Length[aux]}];
(* [end]Get all mass parameters *)





(* Get all gauge and gaugino parameter *)

nonU1sPositions=Position[group[model],x_/;!(x==U1),{1}]//Flatten;
u1sPositions=Position[group[model],U1]//Flatten;
nU1s=Length[u1sPositions];

If[nU1s>0,
gMatrix=Array[g[u1sPositions[[#1]],u1sPositions[[#2]]]&,{nU1s,nU1s}];
mMatrix=Array[M[u1sPositions[[#1]],u1sPositions[[#2]]]&,{nU1s,nU1s}];
,
(* trick the code by assuming that there is an U1 with everything set to 0 *)
gMatrix={};
mMatrix={};
];

If[nU1s==1,
gMatrix=gMatrix/.g[1,1]:>g[1];
mMatrix=mMatrix/.M[1,1]:>M[1];
];
(* [end]Get all gauge and gaugino parameter *)


parameters[model]^={Join[gMatrix//Flatten,g/@nonU1sPositions],Join[mMatrix//Flatten,M/@nonU1sPositions],Sort[pY],Sort[p\[Mu]],Sort[pL],Sort[pH],Sort[pB],Sort[pS],Sort[pM2]};
originalParameters[model]^=parameters[model];

(* Must be called in this order *)
ExcludeUnrealizableParameters[model];
CutUnwantedFlavourIndices[model];
CutUnwantedInvariantIndices[model];
UseFieldNames[model];
]

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)

(* This method is to be called after the model parameters are generated, assuming nothing about the number of flavours. This methods will then take into account the permutation symmetry of the invariant combinations of fields and see what is the induced symmetry on the flavour indices of the parameters. The parameters which, due to antisymmetries are not realizable are then cut from the list of parameters *)
ExcludeUnrealizableParameters[model_]:=Module[{temporaryParameters,symInformation,parameterHead,flavours,types,repsPlusDiscreteCharges,result,aux1,aux2,counter,mainList,snDimentionOfEachFieldCombination,numberOfIndependentParameters},
temporaryParameters=originalParameters[model];
symInformation=ConstantArray[Null,9];
Do[
parameterHead=Switch[part,3,y,4,\[Mu],5,l,6,h,7,b,8,s];
flavours=Array[f,Switch[part,3,3,4,2,5,1,6,3,7,2,8,1]];

types=temporaryParameters[[part,All,1]];
types=Tally[types][[All,1]];
(* Using "PermutationSymmetryOfInvariants[group[model],reps[model][[#]]]&/@types" only will not take into account fields may be distinguisable by the discrete symmetry charges. The solution used is to add temporarily a fake U1 group with these charges - *** NOTE: be sure that this trick works for a list of discrete charges *** *)
repsPlusDiscreteCharges=Flatten[#,1]&/@Transpose[{reps[model],E^discreteSym[model]}];
aux1=PermutationSymmetryOfInvariants[Join[group[model],U1],repsPlusDiscreteCharges[[#]]]&/@types;

(* This is the master list: it for every combination of fields and every snIrrep allowed by it, there is an entry with {A,B,C,D,E},
A=position of the indices involved;
B=model index of the fields involved;
C=Sn irrep;
D=multiplicity of Sn irrep;
E=total number of invariants of this type, taking into account the Sn irrep size and its multiplicity;
F=number of independent (complex in principle) parameters computed taking into account the number of flavors of each field
*)
mainList=Table[{aux1[[fieldCombination,1]],types[[fieldCombination,#]]&/@aux1[[fieldCombination,1]],snIrrep[[1]],snIrrep[[2]],snIrrep[[2]]Times@@(SnIrrepDim/@snIrrep[[1]]),Times@@MapThread[HookContentFormula,{snIrrep[[1]],nFlavs[model][[types[[fieldCombination,#]]]]&/@aux1[[fieldCombination,1,All,1]]}]},{fieldCombination,Length[aux1]},{snIrrep, aux1[[fieldCombination,2]]}];
mainList=Flatten[mainList,1];

aux1={};
aux2={};
Do[
counter=Count[aux1,Sort[Flatten[entry[[2]]]]];
aux1=Join[aux1,ConstantArray[Sort[Flatten[entry[[2]]]],entry[[5]]]];

(* The following If is needed to avoid introducing a "1" invariant index to \[Mu],l,b,s parameters *)
If[part==3||part==6,
aux2=Join[aux2,Table[{parameterHead[Sort[Flatten[entry[[2]]]],counter+j,flavours],entry[[1]],entry[[3]],entry[[6]]},{j,entry[[5]]}]];
,
aux2=Join[aux2,Table[{parameterHead[Sort[Flatten[entry[[2]]]],flavours],entry[[1]],entry[[3]],entry[[6]]},{j,entry[[5]]}]];
]
,{entry,Cases[mainList,x_/;!(x[[6]]===0)]}];


(* Record the information and save it at the end to the model variable *)
temporaryParameters[[part]]=aux2[[All,1]];
symInformation[[part]]=aux2[[All,2;;-1]];

,{part,3,8}];

(* There is no redefinition of parameters here; some of them are simply deleted *)
originalParameters[model]^=temporaryParameters;
parameters[model]^=temporaryParameters;
parametersSymmetries[model]^=symInformation;

];

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)

CutUnwantedFlavourIndices[model_]:=Module[{rules,ruleP1,ruleP2,nfs,aux,s1,s2,s3},

rules={};
Do[
nfs=Switch[part,3,3,4,2,5,1,6,3,7,2,8,1,9,2];
aux=Flatten[Position[parameter[[1]],x_/;!(nFlavs[model][[x]]===1),Heads->False]];
ruleP1=parameter;
ruleP1[[-1]]={s1_,s2_,s3_}[[1;;nfs]];
ruleP2=parameter;
ruleP2[[-1]]={s1,s2,s3}[[aux]];
If[ruleP2[[-1]]==={},ruleP2=Delete[ruleP2,-1]];
AppendTo[rules,ruleP1->ruleP2];

,{part,3,9},{parameter,originalParameters[model][[part]]}];

RenameParametersWithRules[model,rules];
];

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)
(* This applies only to trilinear terms *)
(* Maybe in the future \[Mu],L,b,s terms could from the start have the invariant index supressed *)
CutUnwantedInvariantIndices[model_]:=Module[{rules,ruleP1,ruleP2,numberOfOccurences,aux,s1,s2,s3},

rules={};
Do[

numberOfOccurences=Count[parameters[model][[part,All,1]],parameter[[1]]];

(* kill the invariant index if there is no possible confusion *)
If[numberOfOccurences==1,
ruleP1=parameter;
ruleP2=parameter;
If[Length[parameter]==3,
ruleP1[[3]]={s1_,s2_,s3_}[[1;;Length[parameter[[-1]]]]];
ruleP2[[3]]={s1,s2,s3}[[1;;Length[parameter[[-1]]]]];
];
ruleP2=Delete[ruleP2,2];
AppendTo[rules,ruleP1->ruleP2];
];

,{part,{3,6}},{parameter,parameters[model][[part]]}];

RenameParametersWithRules[model,rules];
];

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)

(* If fieldNames[model] has been defined by the user, the parameter names instead of using each field's position will use the field's name *)
UseFieldNames[model_]:=Module[{rules,more},

If[ValueQ[fieldNames[model]],

rules={};
Do[
AppendTo[rules,parameter[[0]][parameter[[1]],more___]->parameter[[0]][fieldNames[model][[parameter[[1]]]],more]];
,{part,3,9},{parameter,parameters[model][[part]]}];

 RenameParametersWithRules[model,rules]; 
];
]

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)
(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX GENERATING THE LAGRANGIAN XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)
(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)

Options[CalculateLagrangian]={Verbose->True};
CalculateLagrangian[model_,OptionsPattern[]]:=Module[{sum,inv,fNames,result,parts},
result={};
fNames=If[ValueQ[fieldNames[model]],fieldNames[model],Table[ToExpression["\[CapitalPhi]"<>ToString[i]],{i,Length[reps[model]]}]];

parts={{1,2,3},{1,2},{1},{1,2,3},{1,2},{1}};

Do[
sum=0;
Do[
inv=Fold[#1//.#2&,parameter,parameterTransformationRule[model]] Invariants[group[model],reps[model][[parameter[[1]]]]]/. ({a:>If[nFlavs[model][[parameter[[1,1]]]]===1,fNames[[parameter[[1,1]]]],fNames[[parameter[[1,1]]]][f[1]]],b:>If[nFlavs[model][[parameter[[1,2]]]]===1,fNames[[parameter[[1,2]]]],fNames[[parameter[[1,2]]]][f[2]]],c:>If[nFlavs[model][[parameter[[1,3]]]]===1,fNames[[parameter[[1,3]]]],fNames[[parameter[[1,3]]]][f[3]]]}[[parts[[i]]]]);
inv=DeleteCases[inv,0];
If[Length[inv]==0,inv={0}];
inv=If[Length[parameter]>2,inv[[parameter[[2]]]],inv[[1]]];

sum+=inv;
,{parameter,originalParameters[model][[2+i]]}];
AppendTo[result,sum];
,{i,1,6}];

sum=0;
Do[
inv=Fold[#1//.#2&,parameter,parameterTransformationRule[model]] Invariants[group[model],reps[model][[parameter[[1]]]],Conjugations->{False,True}]/. {a:>If[nFlavs[model][[parameter[[1,1]]]]===1,fNames[[parameter[[1,1]]]],fNames[[parameter[[1,1]]]][f[1]]],b:>If[nFlavs[model][[parameter[[1,2]]]]===1,Conjugate[fNames[[parameter[[1,2]]]]],Conjugate[fNames[[parameter[[1,2]]]]][f[2]]]};
inv=DeleteCases[inv,0][[1]];

sum+=inv;
,{parameter,originalParameters[model][[9]]}];
AppendTo[result,sum];

lagrangian[model]^=result;

(* Print the result if needed *)
If[OptionValue[Verbose],PrintLagrangian[model]];

]

(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)
(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX PRINTING FUNCTIONS XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)
(* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *)


PrintModelName[model_]:=Module[{},
PrintHeaderText2["Model name","X",120];
Print[""];
Print[model];
Print[""];
]

PrintModelGaugeGoup[model_]:=Module[{},
PrintHeaderText2["Gauge group","X",120];
Print[""];
Print[StringJoin[Riffle[CMtoName/@group[model]," x "]]];
Print[""];
If[IsModelAnomalyFree[model],
Print[Style["GOOD NEWS:",{Bold,Darker[Green]}],Style[" The model is gauge anomaly free.",Darker[Green]]];,
Print[Style["BAD NEWS:",{Bold,Darker[Red]}],Style[" The model contains gauge anomalies!",Darker[Red]]];
];
Print[""];
]

PrintModelRepresentations[model_]:=
Module[{aux,grayType,result},
grayType=GrayLevel[.9];
result=Table[Tooltip[#[[i]],Grid[{{"Dim(R)","=",DimR[group[model][[i]],#[[i]]]},{"C(R)","=",Casimir[group[model][[i]],#[[i]]]},{"S(R)","=",DynkinIndex[group[model][[i]],#[[i]]]}},Spacings->{0.5,1}],LabelStyle->{Background->Automatic,CellFrameColor->RGBColor[174/256,0,41/256],CellFrame->5}],{i,Length[#]}]&/@reps[model];

result=Prepend[result,Style[CMtoName[#],Bold]&/@group[model]];
result=Transpose[result];

aux=Prepend[nFlavs[model],Style["#Flavours",Bold]];
AppendTo[result,aux];

aux=Prepend[discreteSym[model],Style["R-Charges",Bold]];
AppendTo[result,aux];

TextAngle[texts_,slotSize_]:=If[0^2+Max[StringLength/@ToString/@texts]^2<=slotSize^2,0,ArcCos[N[(slotSize Max[StringLength/@ToString/@texts]+Sqrt[1.5^2-slotSize^2+Max[StringLength/@ToString/@texts]^2])/(1.5^2+Max[StringLength/@ToString/@texts]^2)]]];
TextAngle[texts_String,slotSize_]:=If[1.5^2+Max[StringLength/@texts]^2<=slotSize^2,0,ArcCos[N[(slotSize Max[StringLength/@texts]+Sqrt[1.5^2-slotSize^2+Max[StringLength/@texts]^2])/(1.5^2+Max[StringLength/@texts]^2)]]];

aux=If[ValueQ[fieldNames[model]],Prepend[Table[Rotate[Style[fieldNames[model][[i]],Bold],TextAngle[fieldNames[model],3]],{i,Length[reps[model]]}],Null],Prepend[Table[Rotate[Style["Field "<>ToString[i],Bold],TextAngle[{"Field "<>ToString[Length[reps[model]]]},3]],{i,Length[reps[model]]}],Null]];
PrependTo[result,aux];

result=Grid[result,Alignment->{Center,Center},Dividers->{{2->{grayType,Thick}},{2->{grayType,Thick},-3->{grayType,Thick},-2->{grayType,Thick}}},Spacings->{1,1},ItemSize->{{6}}];


PrintHeaderText2["Representations","X",120];Print[""];
Print[result];Print[""];

]

PrintModelParameters[model_]:=Module[{},
PrintHeaderText2["Parameters in the model","X",120];Print[""];

If[ValueQ[parameters[model]],
PrintHeaderText3["Gauge coupling constants","x",120];Print@@Riffle[parameters[model][[1]],", "];Print[""];
PrintHeaderText3["Gaugino masses","x",120];Print@@Riffle[parameters[model][[2]],", "];Print[""];
PrintHeaderText3["Superpotential trilinear parameters","x",120];Print@@Riffle[parameters[model][[3]],", "];Print[""];
PrintHeaderText3["Superpotential bilinear parameters","x",120];Print@@Riffle[parameters[model][[4]],", "];Print[""];
PrintHeaderText3["Superpotential linear parameters","x",120];Print@@Riffle[parameters[model][[5]],", "];Print[""];
PrintHeaderText3["Soft trilinear parameters","x",120];Print@@Riffle[parameters[model][[6]],", "];Print[""];
PrintHeaderText3["Soft bilinear parameters","x",120];Print@@Riffle[parameters[model][[7]],", "];Print[""];
PrintHeaderText3["Soft linear parameters","x",120];Print@@Riffle[parameters[model][[8]],", "];Print[""];
PrintHeaderText3["Soft masses","x",120];Print@@Riffle[parameters[model][[9]],", "];Print[""];
,
Print["Run ",Style["GenerateModel["<>ToString[model]<>"]",Bold]," to compute the list of model parameters. They will be stored in ",Style["parameters["<>ToString[model]<>"]",Bold],"."];Print[""];
];
]



PrintParametersSymmetries[model_]:=Module[{aux1,aux2,out,syms,anyNonTrivialSymmetry=False},
Do[
aux1=Position[parametersSymmetries[model][[i,j,1]],x_/;Length[x]>1,{1},Heads->False]//Flatten;

(* Condition 1: there must be repeated indices! *)
syms={};
If[Length[aux1]>0,
Do[
aux2=originalParameters[model][[i,j,1,parametersSymmetries[model][[i,j,1,k,1]]]];
(* Condition 2: there must be more than one copy of the repeated fields *)
If[nFlavs[model][[aux2]]=!=1,AppendTo[syms,k]];
,{k,aux1}];
];

(* At this point, syms contains for each parameter (given by i,j) the position in parametersSymmetries[model][[i,j,1]] and parametersSymmetries[model][[i,j,2]] of the symmetries that need to be reported (the non-trivial ones) *)
If[syms=!={},

If[!anyNonTrivialSymmetry,anyNonTrivialSymmetry=True;
PrintHeaderText2["Parameter symmetries under permutations of flavor indices","X",120];Print[""];
];


out={parameters[model][[i,j]]};
Do[
aux1=Which[Length[parametersSymmetries[model][[i,j,2,k]]]==1,{" is symmetric"},Length[parametersSymmetries[model][[i,j,2,k]]]==Total[parametersSymmetries[model][[i,j,2,k]]],{" is antisymmetric"},True,{"transforms as the ",parametersSymmetries[model][[i,j,2,k]]," representation of ",Subscript["S", Total[parametersSymmetries[model][[i,j,2,k]]]]}];
out=Join[out,aux1,{" under a permutation of the flavor indices ",Fold[#1/.#2&,(f/@parametersSymmetries[model][[i,j,1,k]]),parameterRenamingRules[model]],", "}];
,{k,syms}];
out[[-1]]="";
Print[out[[1]],Sequence@@(Style[#,GrayLevel[0.5]]&/@out[[2;;-1]])];
];

,{i,3,8},{j,Length[originalParameters[model][[i]]]}];

If[anyNonTrivialSymmetry,Print[""]];

]



PrintLagrangian[model_]:=Module[{pos,aux0,aux1,aux2,aux3},
PrintHeaderText2["Lagrangian","X",120];
Print[""];
If[ValueQ[lagrangian[model]],

(* Explain the notation *)
pos=Position[group[model],x_/;x!={},{1}]//Flatten;
aux0=(CMtoName[#]<>"_index")&/@DeleteCases[group[model],U1];
aux1="["<>StringJoin[Riffle[(CMtoName[#]<>"_index")&/@DeleteCases[group[model],U1],", "]]<>"]";
Print[Style["Field notation:",GrayLevel[0.5]]];
Do[
aux2=If[Head[fieldNames[model][[i]]]===String,fieldNames[model][[i]],ToString[fieldNames[model][[i]]]]<>If[nFlavs[model][[i]]===1,"","[flavor_index]"];
aux3=StringJoin[Riffle[Table[If[DimR[group[model],reps[model][[i]]][[pos[[j]]]]!=1,aux0[[j]]<>" = 1 to "<>ToString[DimR[group[model],reps[model][[i]]][[pos[[j]]]]],aux0[[j]]<>" = 1"],{j,Length[pos]}],", "]];
aux2=Style["   "<>aux2<>aux1<>"   with   "<>aux3<>".",GrayLevel[0.5]];
Print[aux2];
,{i,Length[reps[model]]}];
Print[""];

PrintHeaderText3["Superpotential (trilinear terms)","x",120];
Print[lagrangian[model][[1]]];
Print[""];
PrintHeaderText3["Superpotential (bilinear terms)","x",120];
Print[lagrangian[model][[2]]];
Print[""];
PrintHeaderText3["Superpotential (linear terms)","x",120];
Print[lagrangian[model][[3]]];
Print[""];
PrintHeaderText3["Soft SUSY breaking Lagrangian (trilinear terms)","x",120];
Print[lagrangian[model][[4]]];
Print[""];
PrintHeaderText3["Soft SUSY breaking Lagrangian (bilinear terms)","x",120];
Print[lagrangian[model][[5]]];
Print[""];
PrintHeaderText3["Soft SUSY breaking Lagrangian (linear terms)","x",120];
Print[lagrangian[model][[6]]];
Print[""];
PrintHeaderText3["Soft SUSY breaking Lagrangian (mass terms)","x",120];
Print[lagrangian[model][[7]]];
Print[""];
,
Print["Run ",Style["GenerateModel["<>ToString[model]<>",CalculateEverything\[Rule]True]",Bold]," to compute the model Lagrangian. It will be stored in ",Style["lagrangian["<>ToString[model]<>"]",Bold],"."];
Print[""];
];

]

PrintModelBetaFunctions[model_]:=Module[{},
PrintHeaderText2["Beta functions","X",120];Print[""];
If[ValueQ[betaFunctions[model]],
Do[
PrintHeaderText3[Row[{"\!\(\*SuperscriptBox[\(\[Beta]\), \((1)\)]\) of ",parameters[model][[i,j]]}],"x",120];Print[Expand[betaFunctions[model][[i,1,j]]]];
Print[""];
PrintHeaderText3[Row[{"\!\(\*SuperscriptBox[\(\[Beta]\), \((2)\)]\) of ",parameters[model][[i,j]]}],"x",120];Print[Expand[betaFunctions[model][[i,2,j]]]];
If[!(i==Length[parameters[model]]&&j==Length[parameters[model][[i]]]),
Print[""];
Print[""];
Print[""];
];
,{i,Length[parameters[model]]},{j,Length[parameters[model][[i]]]}];
,
Print["Run ",Style["GenerateModel["<>ToString[model]<>"]",Bold]," to compute the model \[Beta] functions. They will be stored in ",Style["betaFunctions["<>ToString[model]<>"]",Bold],"."];
];
]

PrintHeaderText[text_,paddingChar_,lineLength_,textColor_:Black]:=Module[{n, leftXs, rightXs,m},
n=StringLength[text];
m=Max[lineLength-4-n,6];
leftXs=StringJoin@@ConstantArray[paddingChar,Quotient[m,2]]<>"  ";
rightXs="  "<>StringJoin@@ConstantArray[paddingChar,m-Quotient[m,2]];

Print[Style[leftXs,GrayLevel[0.5]], Style[text,{Bold,textColor}], Style[rightXs,GrayLevel[0.5]]];
]

PrintHeaderText2[text_,paddingChar_,lineLength_]:=Module[{n, leftXs, rightXs,m},
Print[Style[StringJoin@@ConstantArray[paddingChar,lineLength],GrayLevel[0.5]]];
PrintHeaderText[text,paddingChar,lineLength,Darker[Red]];
Print[Style[StringJoin@@ConstantArray[paddingChar,lineLength],GrayLevel[0.5]]];
]

PrintHeaderText3[text_,paddingChar_,lineLength_,textColor_:Black]:=Module[{n, leftXs, rightXs,m},
n=StringLength[If[Head[text]===String,text,StringReplace[ToString[text],{" "->"","\n"->""}]]];
m=Max[lineLength-4-n-30,6];
leftXs=StringJoin@@ConstantArray[paddingChar,Quotient[m,2]]<>"  ";
rightXs="  "<>StringJoin@@ConstantArray[paddingChar,m-Quotient[m,2]];

Print["               ",Style[leftXs,GrayLevel[0.5]], Style[text,{Bold,textColor}], Style[rightXs,GrayLevel[0.5]],"               "];
]

End[];
EndPackage[];
